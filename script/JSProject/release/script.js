"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.createGithubBranchedRelease = createGithubBranchedRelease;var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _assert = _interopRequireDefault(require("assert"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _nodegit = _interopRequireDefault(require("nodegit"));
var _copyFile = require("../../../source/utility/filesystemOperation/copyFile.js");
const getDirectory = source => _fs.default.readdirSync(source, { withFileTypes: true }).filter(dirent => dirent.isDirectory());
const getAllDirent = source => _fs.default.readdirSync(source, { withFileTypes: true });



async function filterAsync(arr, callback) {
  const fail = Symbol();
  return (await Promise.all(arr.map(async item => (await callback(item)) ? item : fail))).filter(i => i !== fail);
}























async function createGithubBranchedRelease({

  api,
  temporaryBranchName = 'distribution',
  brachToPointTo = 'master',
  commitToPointTo = null,
  tagName,
  buildCallback,
  tagger })


{var _targetProject$config;
  const targetProject = api.project,
  targetProjectConfig = targetProject.configuration.configuration,
  targetProjectRoot = targetProject.configuration.rootPath,
  targetProjectGitUrl = (_targetProject$config = targetProject.configuration.configuration) === null || _targetProject$config === void 0 ? void 0 : _targetProject$config.build.repositoryURL;


  const repository = await _nodegit.default.Repository.open(targetProjectRoot);
  brachToPointTo = await _nodegit.default.Branch.lookup(repository, brachToPointTo, 1);


  let taggerSignature = tagger ? _nodegit.default.Signature.now(tagger.name, tagger.email) : await _nodegit.default.Signature.default(repository);
  (0, _assert.default)(taggerSignature, `âŒ Github username should be passed or found in the git local/system configs.`);


  let getLatestCommit = await repository.getReferenceCommit(brachToPointTo);

  if (commitToPointTo) {
    commitToPointTo = await _nodegit.default.Commit.lookup(repository, commitToPointTo);
  } else commitToPointTo = getLatestCommit;


  let branchReferenceList = await repository.getReferences().then(referenceList => referenceList.filter(reference => reference.type() == _nodegit.default.Reference.TYPE.DIRECT));


  let doesTemporaryBranchExist = branchReferenceList.some(branch => branch.toString().includes(temporaryBranchName));
  let temporaryBranch;
  if (!doesTemporaryBranchExist) {

    temporaryBranch = await _nodegit.default.Branch.create(repository, temporaryBranchName, commitToPointTo, 1).catch(error => console.error(error));
    console.log(`â€¢ Created temporary branch ${await temporaryBranch.name()} from commit ${commitToPointTo.sha()}`);
  } else temporaryBranch = await _nodegit.default.Branch.lookup(repository, temporaryBranchName, 1);


  let statuseList = await repository.getStatus();
  if (statuseList.length > 0)

    await _nodegit.default.Stash.save(repository, taggerSignature, 'checkout stash before release', _nodegit.default.Stash.FLAGS.INCLUDE_UNTRACKED);


  await repository.checkoutBranch((await temporaryBranch.name())).then(async () => console.log(`Checked branch ${await temporaryBranch.name()}`));




  await _nodegit.default.Reset.reset(repository, commitToPointTo, _nodegit.default.Reset.TYPE.HARD).
  then(number => {
    if (number) throw new Error(`â€¢ Could not reset repository ${repository} to commit ${commitToPointTo}`);
  }).
  catch(error => console.error);


  if (buildCallback) await buildCallback().then(() => console.log('Project built successfully !'));



  let gitExcludePath = _path.default.join(targetProjectRoot, './.git/info/exclude'),
  gitIgnorePath = _path.default.join(targetProjectRoot, './.gitignore');
  if (_fs.default.existsSync(gitExcludePath)) _fs.default.unlinkSync(gitExcludePath);
  (0, _copyFile.copyFile)([{ source: gitIgnorePath, destination: gitExcludePath }]);


  let direntList = getAllDirent(targetProjectRoot);








  let ignoredDirectoryList = await filterAsync(direntList, async dirent => {var _ref;return _ref = await _nodegit.default.Ignore.pathIsIgnored(repository, _path.default.join(targetProjectRoot, dirent.name)), Boolean(_ref);});


  let direntToDelete = direntList.filter(dirent => !ignoredDirectoryList.includes(dirent));

  let deleteAbsolutePathList = direntToDelete.map(dirent => _path.default.join(targetProjectRoot, dirent.name));
  for (let absolutePath of deleteAbsolutePathList) {
    _fsExtra.default.removeSync(absolutePath);
  }

  _fsExtra.default.copySync(targetProjectConfig.directory.distribution, targetProjectRoot);


  let index = await repository.refreshIndex();
  let treeObject = await index.
  addAll(['**']).
  then(() => index.write()).
  then(() => index.writeTree());
  let parentCommit = await repository.getHeadCommit();
  await repository.
  createCommit(
  'HEAD' || null,
  taggerSignature,
  taggerSignature,
  `ðŸ—ï¸ Build distribution code.`,
  treeObject,
  [parentCommit]).

  then(oid => console.log(`â€¢ Commit created ${oid} for distribution code`));


  let latestTemporaryBranchCommit = await repository.getHeadCommit();
  await _nodegit.default.Tag.create(repository, tagName, latestTemporaryBranchCommit, taggerSignature, `Release of distribution code only.`, 0).then(oid => console.log(`â€¢ Tag created ${oid}`));


  await repository.checkoutBranch(brachToPointTo).then(async () => console.log(`Checked branch ${await brachToPointTo.name()}`));


  if (statuseList.length > 0) await _nodegit.default.Stash.pop(repository, 0);
}




function rebasingExample({ repository, branch, fromBranch, toBranch }) {
  return repository.rebaseBranches(
  branch.name(),
  fromBranch.name(),
  toBranch.name(),
  _nodegit.default.Signature.now('meow', 'test@example.com'),
  rebase => {
    console.log('One operation');
    return Promise.resolve();
  },
  rebaseMetadata => {
    console.log('Finished rebase');
    return Promise.resolve();
  });

}

async function deleteTemporaryBranch({ repository, temporaryBranch }) {

  try {
    if (_nodegit.default.Branch.isCheckedOut(temporaryBranch)) throw new Error(`Cannot delete a checked out branch ${await temporaryBranch.name()}.`);

    temporaryBranch = await _nodegit.default.Branch.lookup(repository, temporaryBranchName, 1);
    let error = _nodegit.default.Branch.delete(temporaryBranch);
    if (error) throw new Error(`Code thrown by 'libgit2' bindings = ${error}\n \tCheck https://www.nodegit.org/api/error/#CODE`);
    console.log(`â€¢ Deleted tempoarary branch ${await temporaryBranch.name()}.`);
  } catch (error) {
    throw error;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NjcmlwdC9KU1Byb2plY3QvcmVsZWFzZS9zY3JpcHQuanMiXSwibmFtZXMiOlsiZ2V0RGlyZWN0b3J5Iiwic291cmNlIiwiZmlsZXN5c3RlbSIsInJlYWRkaXJTeW5jIiwid2l0aEZpbGVUeXBlcyIsImZpbHRlciIsImRpcmVudCIsImlzRGlyZWN0b3J5IiwiZ2V0QWxsRGlyZW50IiwiZmlsdGVyQXN5bmMiLCJhcnIiLCJjYWxsYmFjayIsImZhaWwiLCJTeW1ib2wiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaXRlbSIsImkiLCJjcmVhdGVHaXRodWJCcmFuY2hlZFJlbGVhc2UiLCJhcGkiLCJ0ZW1wb3JhcnlCcmFuY2hOYW1lIiwiYnJhY2hUb1BvaW50VG8iLCJjb21taXRUb1BvaW50VG8iLCJ0YWdOYW1lIiwiYnVpbGRDYWxsYmFjayIsInRhZ2dlciIsInRhcmdldFByb2plY3QiLCJwcm9qZWN0IiwidGFyZ2V0UHJvamVjdENvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJ0YXJnZXRQcm9qZWN0Um9vdCIsInJvb3RQYXRoIiwidGFyZ2V0UHJvamVjdEdpdFVybCIsImJ1aWxkIiwicmVwb3NpdG9yeVVSTCIsInJlcG9zaXRvcnkiLCJnaXQiLCJSZXBvc2l0b3J5Iiwib3BlbiIsIkJyYW5jaCIsImxvb2t1cCIsInRhZ2dlclNpZ25hdHVyZSIsIlNpZ25hdHVyZSIsIm5vdyIsIm5hbWUiLCJlbWFpbCIsImRlZmF1bHQiLCJnZXRMYXRlc3RDb21taXQiLCJnZXRSZWZlcmVuY2VDb21taXQiLCJDb21taXQiLCJicmFuY2hSZWZlcmVuY2VMaXN0IiwiZ2V0UmVmZXJlbmNlcyIsInRoZW4iLCJyZWZlcmVuY2VMaXN0IiwicmVmZXJlbmNlIiwidHlwZSIsIlJlZmVyZW5jZSIsIlRZUEUiLCJESVJFQ1QiLCJkb2VzVGVtcG9yYXJ5QnJhbmNoRXhpc3QiLCJzb21lIiwiYnJhbmNoIiwidG9TdHJpbmciLCJpbmNsdWRlcyIsInRlbXBvcmFyeUJyYW5jaCIsImNyZWF0ZSIsImNhdGNoIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwic2hhIiwic3RhdHVzZUxpc3QiLCJnZXRTdGF0dXMiLCJsZW5ndGgiLCJTdGFzaCIsInNhdmUiLCJGTEFHUyIsIklOQ0xVREVfVU5UUkFDS0VEIiwiY2hlY2tvdXRCcmFuY2giLCJSZXNldCIsInJlc2V0IiwiSEFSRCIsIm51bWJlciIsIkVycm9yIiwiZ2l0RXhjbHVkZVBhdGgiLCJwYXRoIiwiam9pbiIsImdpdElnbm9yZVBhdGgiLCJleGlzdHNTeW5jIiwidW5saW5rU3luYyIsImRlc3RpbmF0aW9uIiwiZGlyZW50TGlzdCIsImlnbm9yZWREaXJlY3RvcnlMaXN0IiwiSWdub3JlIiwicGF0aElzSWdub3JlZCIsIkJvb2xlYW4iLCJkaXJlbnRUb0RlbGV0ZSIsImRlbGV0ZUFic29sdXRlUGF0aExpc3QiLCJhYnNvbHV0ZVBhdGgiLCJmaWxlc3lzdGVtRXh0cmEiLCJyZW1vdmVTeW5jIiwiY29weVN5bmMiLCJkaXJlY3RvcnkiLCJkaXN0cmlidXRpb24iLCJpbmRleCIsInJlZnJlc2hJbmRleCIsInRyZWVPYmplY3QiLCJhZGRBbGwiLCJ3cml0ZSIsIndyaXRlVHJlZSIsInBhcmVudENvbW1pdCIsImdldEhlYWRDb21taXQiLCJjcmVhdGVDb21taXQiLCJvaWQiLCJsYXRlc3RUZW1wb3JhcnlCcmFuY2hDb21taXQiLCJUYWciLCJwb3AiLCJyZWJhc2luZ0V4YW1wbGUiLCJmcm9tQnJhbmNoIiwidG9CcmFuY2giLCJyZWJhc2VCcmFuY2hlcyIsInJlYmFzZSIsInJlc29sdmUiLCJyZWJhc2VNZXRhZGF0YSIsImRlbGV0ZVRlbXBvcmFyeUJyYW5jaCIsImlzQ2hlY2tlZE91dCIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6ImtPQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxZQUFZLEdBQUdDLE1BQU0sSUFBSUMsWUFBV0MsV0FBWCxDQUF1QkYsTUFBdkIsRUFBK0IsRUFBRUcsYUFBYSxFQUFFLElBQWpCLEVBQS9CLEVBQXdEQyxNQUF4RCxDQUErREMsTUFBTSxJQUFJQSxNQUFNLENBQUNDLFdBQVAsRUFBekUsQ0FBL0I7QUFDQSxNQUFNQyxZQUFZLEdBQUdQLE1BQU0sSUFBSUMsWUFBV0MsV0FBWCxDQUF1QkYsTUFBdkIsRUFBK0IsRUFBRUcsYUFBYSxFQUFFLElBQWpCLEVBQS9CLENBQS9COzs7O0FBSUEsZUFBZUssV0FBZixDQUEyQkMsR0FBM0IsRUFBZ0NDLFFBQWhDLEVBQTBDO0FBQ3hDLFFBQU1DLElBQUksR0FBR0MsTUFBTSxFQUFuQjtBQUNBLFNBQU8sQ0FBQyxNQUFNQyxPQUFPLENBQUNDLEdBQVIsQ0FBWUwsR0FBRyxDQUFDTSxHQUFKLENBQVEsTUFBTUMsSUFBTixJQUFlLENBQUMsTUFBTU4sUUFBUSxDQUFDTSxJQUFELENBQWYsSUFBeUJBLElBQXpCLEdBQWdDTCxJQUF2RCxDQUFaLENBQVAsRUFBbUZQLE1BQW5GLENBQTBGYSxDQUFDLElBQUlBLENBQUMsS0FBS04sSUFBckcsQ0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Qk0sZUFBZU8sMkJBQWYsQ0FBMkM7O0FBRWhEQyxFQUFBQSxHQUZnRDtBQUdoREMsRUFBQUEsbUJBQW1CLEdBQUcsY0FIMEI7QUFJaERDLEVBQUFBLGNBQWMsR0FBRyxRQUorQjtBQUtoREMsRUFBQUEsZUFBZSxHQUFHLElBTDhCO0FBTWhEQyxFQUFBQSxPQU5nRDtBQU9oREMsRUFBQUEsYUFQZ0Q7QUFRaERDLEVBQUFBLE1BUmdELEVBQTNDOzs7QUFXSjtBQUNELFFBQU1DLGFBQWEsR0FBR1AsR0FBRyxDQUFDUSxPQUExQjtBQUNFQyxFQUFBQSxtQkFBbUIsR0FBR0YsYUFBYSxDQUFDRyxhQUFkLENBQTRCQSxhQURwRDtBQUVFQyxFQUFBQSxpQkFBaUIsR0FBR0osYUFBYSxDQUFDRyxhQUFkLENBQTRCRSxRQUZsRDtBQUdFQyxFQUFBQSxtQkFBbUIsNEJBQUdOLGFBQWEsQ0FBQ0csYUFBZCxDQUE0QkEsYUFBL0IsMERBQUcsc0JBQTJDSSxLQUEzQyxDQUFpREMsYUFIekU7OztBQU1BLFFBQU1DLFVBQVUsR0FBRyxNQUFNQyxpQkFBSUMsVUFBSixDQUFlQyxJQUFmLENBQW9CUixpQkFBcEIsQ0FBekI7QUFDQVQsRUFBQUEsY0FBYyxHQUFHLE1BQU1lLGlCQUFJRyxNQUFKLENBQVdDLE1BQVgsQ0FBa0JMLFVBQWxCLEVBQThCZCxjQUE5QixFQUE4QyxDQUE5QyxDQUF2Qjs7O0FBR0EsTUFBSW9CLGVBQWUsR0FBR2hCLE1BQU0sR0FBR1csaUJBQUlNLFNBQUosQ0FBY0MsR0FBZCxDQUFrQmxCLE1BQU0sQ0FBQ21CLElBQXpCLEVBQStCbkIsTUFBTSxDQUFDb0IsS0FBdEMsQ0FBSCxHQUFrRCxNQUFNVCxpQkFBSU0sU0FBSixDQUFjSSxPQUFkLENBQXNCWCxVQUF0QixDQUFwRjtBQUNBLHVCQUFPTSxlQUFQLEVBQXlCLDhFQUF6Qjs7O0FBR0EsTUFBSU0sZUFBZSxHQUFHLE1BQU1aLFVBQVUsQ0FBQ2Esa0JBQVgsQ0FBOEIzQixjQUE5QixDQUE1Qjs7QUFFQSxNQUFJQyxlQUFKLEVBQXFCO0FBQ25CQSxJQUFBQSxlQUFlLEdBQUcsTUFBTWMsaUJBQUlhLE1BQUosQ0FBV1QsTUFBWCxDQUFrQkwsVUFBbEIsRUFBOEJiLGVBQTlCLENBQXhCO0FBQ0QsR0FGRCxNQUVPQSxlQUFlLEdBQUd5QixlQUFsQjs7O0FBR1AsTUFBSUcsbUJBQW1CLEdBQUcsTUFBTWYsVUFBVSxDQUFDZ0IsYUFBWCxHQUEyQkMsSUFBM0IsQ0FBZ0NDLGFBQWEsSUFBSUEsYUFBYSxDQUFDakQsTUFBZCxDQUFxQmtELFNBQVMsSUFBSUEsU0FBUyxDQUFDQyxJQUFWLE1BQW9CbkIsaUJBQUlvQixTQUFKLENBQWNDLElBQWQsQ0FBbUJDLE1BQXpFLENBQWpELENBQWhDOzs7QUFHQSxNQUFJQyx3QkFBd0IsR0FBR1QsbUJBQW1CLENBQUNVLElBQXBCLENBQXlCQyxNQUFNLElBQUlBLE1BQU0sQ0FBQ0MsUUFBUCxHQUFrQkMsUUFBbEIsQ0FBMkIzQyxtQkFBM0IsQ0FBbkMsQ0FBL0I7QUFDQSxNQUFJNEMsZUFBSjtBQUNBLE1BQUksQ0FBQ0wsd0JBQUwsRUFBK0I7O0FBRTdCSyxJQUFBQSxlQUFlLEdBQUcsTUFBTTVCLGlCQUFJRyxNQUFKLENBQVcwQixNQUFYLENBQWtCOUIsVUFBbEIsRUFBOEJmLG1CQUE5QixFQUFtREUsZUFBbkQsRUFBb0UsQ0FBcEUsRUFBdUU0QyxLQUF2RSxDQUE2RUMsS0FBSyxJQUFJQyxPQUFPLENBQUNELEtBQVIsQ0FBY0EsS0FBZCxDQUF0RixDQUF4QjtBQUNBQyxJQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBYSw4QkFBNkIsTUFBTUwsZUFBZSxDQUFDcEIsSUFBaEIsRUFBdUIsZ0JBQWV0QixlQUFlLENBQUNnRCxHQUFoQixFQUFzQixFQUE1RztBQUNELEdBSkQsTUFJT04sZUFBZSxHQUFHLE1BQU01QixpQkFBSUcsTUFBSixDQUFXQyxNQUFYLENBQWtCTCxVQUFsQixFQUE4QmYsbUJBQTlCLEVBQW1ELENBQW5ELENBQXhCOzs7QUFHUCxNQUFJbUQsV0FBVyxHQUFHLE1BQU1wQyxVQUFVLENBQUNxQyxTQUFYLEVBQXhCO0FBQ0EsTUFBSUQsV0FBVyxDQUFDRSxNQUFaLEdBQXFCLENBQXpCOztBQUVFLFVBQU1yQyxpQkFBSXNDLEtBQUosQ0FBVUMsSUFBVixDQUFleEMsVUFBZixFQUEyQk0sZUFBM0IsRUFBNEMsK0JBQTVDLEVBQTZFTCxpQkFBSXNDLEtBQUosQ0FBVUUsS0FBVixDQUFnQkMsaUJBQTdGLENBQU47OztBQUdGLFFBQU0xQyxVQUFVLENBQUMyQyxjQUFYLEVBQTBCLE1BQU1kLGVBQWUsQ0FBQ3BCLElBQWhCLEVBQWhDLEdBQXdEUSxJQUF4RCxDQUE2RCxZQUFZZ0IsT0FBTyxDQUFDQyxHQUFSLENBQWEsa0JBQWlCLE1BQU1MLGVBQWUsQ0FBQ3BCLElBQWhCLEVBQXVCLEVBQTNELENBQXpFLENBQU47Ozs7O0FBS0EsUUFBTVIsaUJBQUkyQyxLQUFKLENBQVVDLEtBQVYsQ0FBZ0I3QyxVQUFoQixFQUE0QmIsZUFBNUIsRUFBNkNjLGlCQUFJMkMsS0FBSixDQUFVdEIsSUFBVixDQUFld0IsSUFBNUQ7QUFDSDdCLEVBQUFBLElBREcsQ0FDRThCLE1BQU0sSUFBSTtBQUNkLFFBQUlBLE1BQUosRUFBWSxNQUFNLElBQUlDLEtBQUosQ0FBVyxnQ0FBK0JoRCxVQUFXLGNBQWFiLGVBQWdCLEVBQWxGLENBQU47QUFDYixHQUhHO0FBSUg0QyxFQUFBQSxLQUpHLENBSUdDLEtBQUssSUFBSUMsT0FBTyxDQUFDRCxLQUpwQixDQUFOOzs7QUFPQSxNQUFJM0MsYUFBSixFQUFtQixNQUFNQSxhQUFhLEdBQUc0QixJQUFoQixDQUFxQixNQUFNZ0IsT0FBTyxDQUFDQyxHQUFSLENBQVksOEJBQVosQ0FBM0IsQ0FBTjs7OztBQUluQixNQUFJZSxjQUFjLEdBQUdDLGNBQUtDLElBQUwsQ0FBVXhELGlCQUFWLEVBQTZCLHFCQUE3QixDQUFyQjtBQUNFeUQsRUFBQUEsYUFBYSxHQUFHRixjQUFLQyxJQUFMLENBQVV4RCxpQkFBVixFQUE2QixjQUE3QixDQURsQjtBQUVBLE1BQUk3QixZQUFXdUYsVUFBWCxDQUFzQkosY0FBdEIsQ0FBSixFQUEyQ25GLFlBQVd3RixVQUFYLENBQXNCTCxjQUF0QjtBQUMzQywwQkFBUyxDQUFDLEVBQUVwRixNQUFNLEVBQUV1RixhQUFWLEVBQXlCRyxXQUFXLEVBQUVOLGNBQXRDLEVBQUQsQ0FBVDs7O0FBR0EsTUFBSU8sVUFBVSxHQUFHcEYsWUFBWSxDQUFDdUIsaUJBQUQsQ0FBN0I7Ozs7Ozs7OztBQVNBLE1BQUk4RCxvQkFBb0IsR0FBRyxNQUFNcEYsV0FBVyxDQUFDbUYsVUFBRCxFQUFhLE1BQU10RixNQUFOLDRCQUFpQixNQUFNK0IsaUJBQUl5RCxNQUFKLENBQVdDLGFBQVgsQ0FBeUIzRCxVQUF6QixFQUFxQ2tELGNBQUtDLElBQUwsQ0FBVXhELGlCQUFWLEVBQTZCekIsTUFBTSxDQUFDdUMsSUFBcEMsQ0FBckMsQ0FBdkIsRUFBMkdtRCxPQUEzRyxRQUFiLENBQTVDOzs7QUFHQSxNQUFJQyxjQUFjLEdBQUdMLFVBQVUsQ0FBQ3ZGLE1BQVgsQ0FBa0JDLE1BQU0sSUFBSSxDQUFDdUYsb0JBQW9CLENBQUM3QixRQUFyQixDQUE4QjFELE1BQTlCLENBQTdCLENBQXJCOztBQUVBLE1BQUk0RixzQkFBc0IsR0FBR0QsY0FBYyxDQUFDakYsR0FBZixDQUFtQlYsTUFBTSxJQUFJZ0YsY0FBS0MsSUFBTCxDQUFVeEQsaUJBQVYsRUFBNkJ6QixNQUFNLENBQUN1QyxJQUFwQyxDQUE3QixDQUE3QjtBQUNBLE9BQUssSUFBSXNELFlBQVQsSUFBeUJELHNCQUF6QixFQUFpRDtBQUMvQ0UscUJBQWdCQyxVQUFoQixDQUEyQkYsWUFBM0I7QUFDRDs7QUFFREMsbUJBQWdCRSxRQUFoQixDQUF5QnpFLG1CQUFtQixDQUFDMEUsU0FBcEIsQ0FBOEJDLFlBQXZELEVBQXFFekUsaUJBQXJFOzs7QUFHQSxNQUFJMEUsS0FBSyxHQUFHLE1BQU1yRSxVQUFVLENBQUNzRSxZQUFYLEVBQWxCO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLE1BQU1GLEtBQUs7QUFDekJHLEVBQUFBLE1BRG9CLENBQ2IsQ0FBQyxJQUFELENBRGE7QUFFcEJ2RCxFQUFBQSxJQUZvQixDQUVmLE1BQU1vRCxLQUFLLENBQUNJLEtBQU4sRUFGUztBQUdwQnhELEVBQUFBLElBSG9CLENBR2YsTUFBTW9ELEtBQUssQ0FBQ0ssU0FBTixFQUhTLENBQXZCO0FBSUEsTUFBSUMsWUFBWSxHQUFHLE1BQU0zRSxVQUFVLENBQUM0RSxhQUFYLEVBQXpCO0FBQ0EsUUFBTTVFLFVBQVU7QUFDYjZFLEVBQUFBLFlBREc7QUFFRixZQUEwRixJQUZ4RjtBQUdGdkUsRUFBQUEsZUFIRTtBQUlGQSxFQUFBQSxlQUpFO0FBS0QsZ0NBTEM7QUFNRmlFLEVBQUFBLFVBTkU7QUFPRixHQUFDSSxZQUFELENBUEU7O0FBU0gxRCxFQUFBQSxJQVRHLENBU0U2RCxHQUFHLElBQUk3QyxPQUFPLENBQUNDLEdBQVIsQ0FBYSxvQkFBbUI0QyxHQUFJLHdCQUFwQyxDQVRULENBQU47OztBQVlBLE1BQUlDLDJCQUEyQixHQUFHLE1BQU0vRSxVQUFVLENBQUM0RSxhQUFYLEVBQXhDO0FBQ0EsUUFBTTNFLGlCQUFJK0UsR0FBSixDQUFRbEQsTUFBUixDQUFlOUIsVUFBZixFQUEyQlosT0FBM0IsRUFBb0MyRiwyQkFBcEMsRUFBaUV6RSxlQUFqRSxFQUFtRixvQ0FBbkYsRUFBd0gsQ0FBeEgsRUFBMkhXLElBQTNILENBQWdJNkQsR0FBRyxJQUFJN0MsT0FBTyxDQUFDQyxHQUFSLENBQWEsaUJBQWdCNEMsR0FBSSxFQUFqQyxDQUF2SSxDQUFOOzs7QUFHQSxRQUFNOUUsVUFBVSxDQUFDMkMsY0FBWCxDQUEwQnpELGNBQTFCLEVBQTBDK0IsSUFBMUMsQ0FBK0MsWUFBWWdCLE9BQU8sQ0FBQ0MsR0FBUixDQUFhLGtCQUFpQixNQUFNaEQsY0FBYyxDQUFDdUIsSUFBZixFQUFzQixFQUExRCxDQUEzRCxDQUFOOzs7QUFHQSxNQUFJMkIsV0FBVyxDQUFDRSxNQUFaLEdBQXFCLENBQXpCLEVBQTRCLE1BQU1yQyxpQkFBSXNDLEtBQUosQ0FBVTBDLEdBQVYsQ0FBY2pGLFVBQWQsRUFBMEIsQ0FBMUIsQ0FBTjtBQUM3Qjs7Ozs7QUFLRCxTQUFTa0YsZUFBVCxDQUF5QixFQUFFbEYsVUFBRixFQUFjMEIsTUFBZCxFQUFzQnlELFVBQXRCLEVBQWtDQyxRQUFsQyxFQUF6QixFQUF1RTtBQUNyRSxTQUFPcEYsVUFBVSxDQUFDcUYsY0FBWDtBQUNMM0QsRUFBQUEsTUFBTSxDQUFDakIsSUFBUCxFQURLO0FBRUwwRSxFQUFBQSxVQUFVLENBQUMxRSxJQUFYLEVBRks7QUFHTDJFLEVBQUFBLFFBQVEsQ0FBQzNFLElBQVQsRUFISztBQUlMUixtQkFBSU0sU0FBSixDQUFjQyxHQUFkLENBQWtCLE1BQWxCLEVBQTBCLGtCQUExQixDQUpLO0FBS0w4RSxFQUFBQSxNQUFNLElBQUk7QUFDUnJELElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGVBQVo7QUFDQSxXQUFPeEQsT0FBTyxDQUFDNkcsT0FBUixFQUFQO0FBQ0QsR0FSSTtBQVNMQyxFQUFBQSxjQUFjLElBQUk7QUFDaEJ2RCxJQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxpQkFBWjtBQUNBLFdBQU94RCxPQUFPLENBQUM2RyxPQUFSLEVBQVA7QUFDRCxHQVpJLENBQVA7O0FBY0Q7O0FBRUQsZUFBZUUscUJBQWYsQ0FBcUMsRUFBRXpGLFVBQUYsRUFBYzZCLGVBQWQsRUFBckMsRUFBc0U7O0FBRXBFLE1BQUk7QUFDRixRQUFJNUIsaUJBQUlHLE1BQUosQ0FBV3NGLFlBQVgsQ0FBd0I3RCxlQUF4QixDQUFKLEVBQThDLE1BQU0sSUFBSW1CLEtBQUosQ0FBVyxzQ0FBcUMsTUFBTW5CLGVBQWUsQ0FBQ3BCLElBQWhCLEVBQXVCLEdBQTdFLENBQU47O0FBRTlDb0IsSUFBQUEsZUFBZSxHQUFHLE1BQU01QixpQkFBSUcsTUFBSixDQUFXQyxNQUFYLENBQWtCTCxVQUFsQixFQUE4QmYsbUJBQTlCLEVBQW1ELENBQW5ELENBQXhCO0FBQ0EsUUFBSStDLEtBQUssR0FBRy9CLGlCQUFJRyxNQUFKLENBQVd1RixNQUFYLENBQWtCOUQsZUFBbEIsQ0FBWjtBQUNBLFFBQUlHLEtBQUosRUFBVyxNQUFNLElBQUlnQixLQUFKLENBQVcsdUNBQXNDaEIsS0FBTSxvREFBdkQsQ0FBTjtBQUNYQyxJQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBYSwrQkFBOEIsTUFBTUwsZUFBZSxDQUFDcEIsSUFBaEIsRUFBdUIsR0FBeEU7QUFDRCxHQVBELENBT0UsT0FBT3VCLEtBQVAsRUFBYztBQUNkLFVBQU1BLEtBQU47QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZpbGVzeXN0ZW0gZnJvbSAnZnMnXHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXHJcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0J1xyXG5pbXBvcnQgY2hpbGRQcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnXHJcbmltcG9ydCBmaWxlc3lzdGVtRXh0cmEgZnJvbSAnZnMtZXh0cmEnXHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZ2l0LCBDb21taXQsIFJlcG9zaXRvcnksIFJlZmVyZW5jZSwgQnJhbmNoLCBTaWduYXR1cmUsIFJlc2V0LCBTdGFzaCB9IGZyb20gJ25vZGVnaXQnXHJcbmltcG9ydCB7IGNvcHlGaWxlIH0gZnJvbSAnLi4vLi4vLi4vc291cmNlL3V0aWxpdHkvZmlsZXN5c3RlbU9wZXJhdGlvbi9jb3B5RmlsZS5qcydcclxuY29uc3QgZ2V0RGlyZWN0b3J5ID0gc291cmNlID0+IGZpbGVzeXN0ZW0ucmVhZGRpclN5bmMoc291cmNlLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSkuZmlsdGVyKGRpcmVudCA9PiBkaXJlbnQuaXNEaXJlY3RvcnkoKSlcclxuY29uc3QgZ2V0QWxsRGlyZW50ID0gc291cmNlID0+IGZpbGVzeXN0ZW0ucmVhZGRpclN5bmMoc291cmNlLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcclxuLyoqIEZpbHRlciBhcnJheSB3aXRoIGFzeW5jIGZ1bmN0aW9uXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzMzU1NTI4L2ZpbHRlcmluZy1hbi1hcnJheS13aXRoLWEtZnVuY3Rpb24tdGhhdC1yZXR1cm5zLWEtcHJvbWlzZVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmlsdGVyQXN5bmMoYXJyLCBjYWxsYmFjaykge1xyXG4gIGNvbnN0IGZhaWwgPSBTeW1ib2woKVxyXG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoYXJyLm1hcChhc3luYyBpdGVtID0+ICgoYXdhaXQgY2FsbGJhY2soaXRlbSkpID8gaXRlbSA6IGZhaWwpKSkpLmZpbHRlcihpID0+IGkgIT09IGZhaWwpXHJcbn1cclxuXHJcbi8vPyBUT0RPOiBSZWxlYXNlcyBjb3VsZCBiZSBjcmVhdGVkIGZvciBzb3VyY2UgY29kZSBhbmQgZm9yIGRpc3RyaWJ1dGlvbiBjb2RlXHJcblxyXG4vKipcclxuICog4peLIFB1c2ggbmV3IHZlcnNpb24gdG8gZ2l0aHViIHRhZ3MuXHJcbiAqIOKXiyBDcmVhdGUgYSBuZXcgcmVsZWFzZSBmcm9tIHRoZSBwdXNoZWQgdGFnLlxyXG4gKiBSZWxlYXNlIGEgbmV3IHRhZyBpbiBHaXRodWI6XHJcbiAqICAwLiBzdGFzaCBjaGFuZ2VzIHRlbXBvcmFyaWx5XHJcbiAqICAxLiBDcmVhdGUgYSB0ZW1wb3JhcnkgYnJhbmNoIG9yIHVzZSBhbiBleGlzdGluZyBicmFuY2ggYW5kIGNoZWNrb3V0IHRvIGl0LlxyXG4gKiAgMi4gUmViYXNlIG9yIFJlc2V0aW5nIG9udG8gbWFzdGVyIChpbiBjYXNlIHRoZSB0ZW1wb3JhcnkgYnJhbmNoIGV4aXN0cykgLSBzaW1pbGFyIHRvIG92ZXJyaWRpbmcgYnJhbmNoIGhpc3Rvcnkgd2l0aCB0aGUgbWFzdGVyIGJyYW5jaC5cclxuICogIDMuIEJ1aWxkIGNvZGUgYW5kIGNvbW1pdCB3aXRoIGEgZGlzdHJpYnV0aW9uIG1lc3NhZ2UuXHJcbiAqICA0LiBDcmVhdGUgYSByZWxlYXNlL3RhZy5cclxuICogIDUuIGNsZWFudXAgYnJhbmNoZXMuXHJcbiAqICA2LiBnaXQgY2hlY2tvdXQgbWFzdGVyXHJcbiAqICA3LiBwb3AgbGFzdCBzdGFzaCBmaWxlc1xyXG4gKlxyXG4gKiAgQHNpZUVmZmVjdCAtIGNyZWF0ZXMgYSB0YWcgYW5kIGRlbGV0ZXMgdGVtcG9yYXJ5IGJyYW5jaC5cclxuICpcclxuICogU2ltcGxlIGV4YW1wbGUgZXF1aXZhbGVudCBzaGVsbCBzY3JpcHQ6XHJcbiAqIGBgYGdpdCBjaGVja291dCBkaXN0cmlidXRpb24gJiYgZ2l0IHJlYmFzZSAtLW9udG8gbWFzdGVyIGRpc3RyaWJ1dGlvbiAmJiBlY2hvIFwiVGVzdCBQYWdlXCIgPiBuZXcuanMgJiYgZ2l0IGFkZCAtQSAmJiBnaXQgY29tbWl0IC1hIC1tICdidWlsZCcgJiYgZ2l0IHRhZyB2NTsgZ2l0IGNoZWNrb3V0IG1hc3RlcmBgYFxyXG4gKlxyXG4gKiBgbm9kZWdpdGAgZG9jdW1lbnRhdGlvbjogaHR0cHM6Ly93d3cubm9kZWdpdC5vcmcvYXBpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2l0aHViQnJhbmNoZWRSZWxlYXNlKHtcclxuICAvLyAnYnJhbmNoZWQgcmVsZWFzZScgaW4gdGhlIHNlbnNlIG9mIGEgdGFnIHRoYXQgcG9pbnRzIHRvIGFuIGFkZGl0aW9uYWwgYnVpbGQgY29tbWl0IG90aGVyIHRoYW4gdGhlIG1hc3RlciBjb21taXQgZm9yIGV4YW1wbGUuXHJcbiAgYXBpLFxyXG4gIHRlbXBvcmFyeUJyYW5jaE5hbWUgPSAnZGlzdHJpYnV0aW9uJywgLy8gYnJhbmNoIHVzZWQgdG8gYnVpbGQgc291cmNlIGNvZGUgYW5kIGNyZWF0ZSBhIGRpc3RyaWJ1dGlvbiB0YWcgZnJvbVxyXG4gIGJyYWNoVG9Qb2ludFRvID0gJ21hc3RlcicsIC8vIGRlZmF1bHQgYnJhbmNoIGZvciBsYXRlc3QgY29tbWl0LlxyXG4gIGNvbW1pdFRvUG9pbnRUbyA9IG51bGwsIC8vIHVucmVsYXRlZCBjb21taXQgdG8gcG9pbnQgdG8gd2hpbGUgY3JlYXRpbmcgdGVtcG9yYXJ5IGJyYW5jaFxyXG4gIHRhZ05hbWUsXHJcbiAgYnVpbGRDYWxsYmFjaywgLy8gYnVpbGQgYXN5bmMgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSBidWlsZGluZyBzb3VyY2UgY29kZSBhbmQgcHJlcGFyaW5nIHRoZSBwYWNrYWdlIGZvciBkaXN0cmlidXRpb24uXHJcbiAgdGFnZ2VyLFxyXG59OiB7XHJcbiAgdGFnZ2VyOiB7IG5hbWU6ICcnLCBlbWFpbDogJycgfSxcclxufSkge1xyXG4gIGNvbnN0IHRhcmdldFByb2plY3QgPSBhcGkucHJvamVjdCxcclxuICAgIHRhcmdldFByb2plY3RDb25maWcgPSB0YXJnZXRQcm9qZWN0LmNvbmZpZ3VyYXRpb24uY29uZmlndXJhdGlvbixcclxuICAgIHRhcmdldFByb2plY3RSb290ID0gdGFyZ2V0UHJvamVjdC5jb25maWd1cmF0aW9uLnJvb3RQYXRoLFxyXG4gICAgdGFyZ2V0UHJvamVjdEdpdFVybCA9IHRhcmdldFByb2plY3QuY29uZmlndXJhdGlvbi5jb25maWd1cmF0aW9uPy5idWlsZC5yZXBvc2l0b3J5VVJMXHJcblxyXG4gIC8vIHJlYWQgZ2l0IHJlcG9zaXRvcnlcclxuICBjb25zdCByZXBvc2l0b3J5ID0gYXdhaXQgZ2l0LlJlcG9zaXRvcnkub3Blbih0YXJnZXRQcm9qZWN0Um9vdClcclxuICBicmFjaFRvUG9pbnRUbyA9IGF3YWl0IGdpdC5CcmFuY2gubG9va3VwKHJlcG9zaXRvcnksIGJyYWNoVG9Qb2ludFRvLCAxKSAvLyBjb252ZXJ0IHRvIGJyYW5jaCByZWZlcmVuY2VcclxuXHJcbiAgLy8gbG9hZCB0YWdnZXJTaWduYXR1cmUgc2lnbmF0dXJlXHJcbiAgbGV0IHRhZ2dlclNpZ25hdHVyZSA9IHRhZ2dlciA/IGdpdC5TaWduYXR1cmUubm93KHRhZ2dlci5uYW1lLCB0YWdnZXIuZW1haWwpIDogYXdhaXQgZ2l0LlNpZ25hdHVyZS5kZWZhdWx0KHJlcG9zaXRvcnkpXHJcbiAgYXNzZXJ0KHRhZ2dlclNpZ25hdHVyZSwgYOKdjCBHaXRodWIgdXNlcm5hbWUgc2hvdWxkIGJlIHBhc3NlZCBvciBmb3VuZCBpbiB0aGUgZ2l0IGxvY2FsL3N5c3RlbSBjb25maWdzLmApXHJcblxyXG4gIC8vIGdldCBsYXRlc3QgY29tbWl0IGZyb20gYnJhbmNoXHJcbiAgbGV0IGdldExhdGVzdENvbW1pdCA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0UmVmZXJlbmNlQ29tbWl0KGJyYWNoVG9Qb2ludFRvKVxyXG4gIC8vIHNldCBjb21taXQgcmVmZXJlbmNlXHJcbiAgaWYgKGNvbW1pdFRvUG9pbnRUbykge1xyXG4gICAgY29tbWl0VG9Qb2ludFRvID0gYXdhaXQgZ2l0LkNvbW1pdC5sb29rdXAocmVwb3NpdG9yeSwgY29tbWl0VG9Qb2ludFRvKSAvLyBnZXQgY29tbWl0IGZyb20gc3VwcGxpZWQgY29tbWl0IGlkIHBhcmFtZXRlclxyXG4gIH0gZWxzZSBjb21taXRUb1BvaW50VG8gPSBnZXRMYXRlc3RDb21taXRcclxuXHJcbiAgLy8gZ2V0IGFsbCBicmFuY2hlcyByZW1vdGUgYW5kIGxvY2FsXHJcbiAgbGV0IGJyYW5jaFJlZmVyZW5jZUxpc3QgPSBhd2FpdCByZXBvc2l0b3J5LmdldFJlZmVyZW5jZXMoKS50aGVuKHJlZmVyZW5jZUxpc3QgPT4gcmVmZXJlbmNlTGlzdC5maWx0ZXIocmVmZXJlbmNlID0+IHJlZmVyZW5jZS50eXBlKCkgPT0gZ2l0LlJlZmVyZW5jZS5UWVBFLkRJUkVDVCkpXHJcblxyXG4gIC8vIGNoZWNrIGlmIGB0ZW1wb3JhcnlCcmFuY2hOYW1lYCBicmFuY2gsIHRoYXQgaXMgdXNlZCwgZXhpc3RzLlxyXG4gIGxldCBkb2VzVGVtcG9yYXJ5QnJhbmNoRXhpc3QgPSBicmFuY2hSZWZlcmVuY2VMaXN0LnNvbWUoYnJhbmNoID0+IGJyYW5jaC50b1N0cmluZygpLmluY2x1ZGVzKHRlbXBvcmFyeUJyYW5jaE5hbWUpKVxyXG4gIGxldCB0ZW1wb3JhcnlCcmFuY2ggLy8gQnJhbmNoIHJlZmVyZW5jZVxyXG4gIGlmICghZG9lc1RlbXBvcmFyeUJyYW5jaEV4aXN0KSB7XHJcbiAgICAvLyBjcmVhdGUgdGVtcG9yYXJ5IGJyYW5jaFxyXG4gICAgdGVtcG9yYXJ5QnJhbmNoID0gYXdhaXQgZ2l0LkJyYW5jaC5jcmVhdGUocmVwb3NpdG9yeSwgdGVtcG9yYXJ5QnJhbmNoTmFtZSwgY29tbWl0VG9Qb2ludFRvLCAxKS5jYXRjaChlcnJvciA9PiBjb25zb2xlLmVycm9yKGVycm9yKSlcclxuICAgIGNvbnNvbGUubG9nKGDigKIgQ3JlYXRlZCB0ZW1wb3JhcnkgYnJhbmNoICR7YXdhaXQgdGVtcG9yYXJ5QnJhbmNoLm5hbWUoKX0gZnJvbSBjb21taXQgJHtjb21taXRUb1BvaW50VG8uc2hhKCl9YClcclxuICB9IGVsc2UgdGVtcG9yYXJ5QnJhbmNoID0gYXdhaXQgZ2l0LkJyYW5jaC5sb29rdXAocmVwb3NpdG9yeSwgdGVtcG9yYXJ5QnJhbmNoTmFtZSwgMSlcclxuXHJcbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHVudHJhY2tlZCBvciBzdGFnZWQgZmlsZXNcclxuICBsZXQgc3RhdHVzZUxpc3QgPSBhd2FpdCByZXBvc2l0b3J5LmdldFN0YXR1cygpXHJcbiAgaWYgKHN0YXR1c2VMaXN0Lmxlbmd0aCA+IDApXHJcbiAgICAvLyBzdGFzaCBjaGFuZ2VzIHRoYXQgYXJlIHN0aWxsIG5vdCBjb21taXR0ZWRcclxuICAgIGF3YWl0IGdpdC5TdGFzaC5zYXZlKHJlcG9zaXRvcnksIHRhZ2dlclNpZ25hdHVyZSwgJ2NoZWNrb3V0IHN0YXNoIGJlZm9yZSByZWxlYXNlJywgZ2l0LlN0YXNoLkZMQUdTLklOQ0xVREVfVU5UUkFDS0VEKVxyXG5cclxuICAvLyBjaGVja291dCB0ZW1wb3JhcnlcclxuICBhd2FpdCByZXBvc2l0b3J5LmNoZWNrb3V0QnJhbmNoKGF3YWl0IHRlbXBvcmFyeUJyYW5jaC5uYW1lKCkpLnRoZW4oYXN5bmMgKCkgPT4gY29uc29sZS5sb2coYENoZWNrZWQgYnJhbmNoICR7YXdhaXQgdGVtcG9yYXJ5QnJhbmNoLm5hbWUoKX1gKSlcclxuXHJcbiAgLyoqIHJlc2V0IHRlbXBvcmFyeSBicmFuY2ggdG8gdGhlIGNvbW1pdCB0byBwb2ludCB0byAodGFyZ2V0Q29tbWl0KVxyXG4gICAqIE5PVEU6IEFub3RoZXIgb3B0aW9uIGlzIHRvIHVzZSByZWJhc2luZyB3aGVyZSBjdXJyZW50IGNvbW1pdHMgYXJlIHNhdmVkIC0gY2hlY2sgIGByZWJhc2luZ0V4YW1wbGUoKWAgZnVuY3Rpb25cclxuICAgKi9cclxuICBhd2FpdCBnaXQuUmVzZXQucmVzZXQocmVwb3NpdG9yeSwgY29tbWl0VG9Qb2ludFRvLCBnaXQuUmVzZXQuVFlQRS5IQVJEKVxyXG4gICAgLnRoZW4obnVtYmVyID0+IHtcclxuICAgICAgaWYgKG51bWJlcikgdGhyb3cgbmV3IEVycm9yKGDigKIgQ291bGQgbm90IHJlc2V0IHJlcG9zaXRvcnkgJHtyZXBvc2l0b3J5fSB0byBjb21taXQgJHtjb21taXRUb1BvaW50VG99YClcclxuICAgIH0pXHJcbiAgICAuY2F0Y2goZXJyb3IgPT4gY29uc29sZS5lcnJvcilcclxuXHJcbiAgLy8gcnVuIGJ1aWxkXHJcbiAgaWYgKGJ1aWxkQ2FsbGJhY2spIGF3YWl0IGJ1aWxkQ2FsbGJhY2soKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdQcm9qZWN0IGJ1aWx0IHN1Y2Nlc3NmdWxseSAhJykpXHJcblxyXG4gIC8qKiBNYWtlIGRpc3RyaWJ1dGlvbiBmb2xkZXIgYXMgcm9vdCBkaXJlY3RvcnkgaW4gdGhlIGJyYW5jaCAqL1xyXG4gIC8vIGRlbGV0aW5nIC5naXRpZ25vcmUgd2lsbCBtYWtlIGl0IGZhc3RlciwgYnkgcHJldmVudGluZyBub2RlX21vZHVsZXMgZnJvbSBiZWluZyBwcm9jZXNzZWQgYnkgdG9vbHMgd2hpbGUgZGVsZXRpbmcgZmlsZXMuXHJcbiAgbGV0IGdpdEV4Y2x1ZGVQYXRoID0gcGF0aC5qb2luKHRhcmdldFByb2plY3RSb290LCAnLi8uZ2l0L2luZm8vZXhjbHVkZScpLFxyXG4gICAgZ2l0SWdub3JlUGF0aCA9IHBhdGguam9pbih0YXJnZXRQcm9qZWN0Um9vdCwgJy4vLmdpdGlnbm9yZScpXHJcbiAgaWYgKGZpbGVzeXN0ZW0uZXhpc3RzU3luYyhnaXRFeGNsdWRlUGF0aCkpIGZpbGVzeXN0ZW0udW5saW5rU3luYyhnaXRFeGNsdWRlUGF0aCkgLy8gcmVtb3ZlIGZpbGVcclxuICBjb3B5RmlsZShbeyBzb3VyY2U6IGdpdElnbm9yZVBhdGgsIGRlc3RpbmF0aW9uOiBnaXRFeGNsdWRlUGF0aCB9XSkgLy8gY29weSAuZ2l0aWdub3JlIHRvIGAuZ2l0YCBmb2xkZXJcclxuXHJcbiAgLy8gZ2V0IHRvcCBkaXJlY3RvcmllcyB0aGF0IGFyZSBpZ25vcmVkXHJcbiAgbGV0IGRpcmVudExpc3QgPSBnZXRBbGxEaXJlbnQodGFyZ2V0UHJvamVjdFJvb3QpIC8vIGdldCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIG9uIHRvcCBsZXZlbFxyXG5cclxuICAvLyBUT0RPOiBEZWFsIHdpdGggc3ViZGlyZWN0b3J5IG5vZGVfbW9kdWxlcyBhbmQgaWdub3JlZCBmaWxlcy4gVGhlIGlzc3VlcyBpcyB0aGF0IHRoZSB3aG9sZSB0b3BsZXZlbCBkaXJlY3RvcnkgaXMgcmVtb3ZlZC5cclxuICAvLyAvLyBnZXQgYWxsIDJuZCBsZXZlbCBkaXJlY3RvcmllcyAtIHRoaXMgYWxsb3dzIGZvciB3b3Jrc3BhY2VzIHRvIGtlZXAgbm9kZV9tb2R1bGVzIGZvbGRlciBpbiBhIHN1YmRpcmVjdG9yeS5cclxuICAvLyBmb3IgKGxldCB0b3BsZXZlbERpcmVudCBvZiBkaXJlbnRMaXN0KSB7XHJcbiAgLy8gICBsZXQgc3ViRGlyZW50TGlzdCA9XHJcbiAgLy8gfVxyXG5cclxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGlnbm9yZWRcclxuICBsZXQgaWdub3JlZERpcmVjdG9yeUxpc3QgPSBhd2FpdCBmaWx0ZXJBc3luYyhkaXJlbnRMaXN0LCBhc3luYyBkaXJlbnQgPT4gKGF3YWl0IGdpdC5JZ25vcmUucGF0aElzSWdub3JlZChyZXBvc2l0b3J5LCBwYXRoLmpvaW4odGFyZ2V0UHJvamVjdFJvb3QsIGRpcmVudC5uYW1lKSkpIHw+IEJvb2xlYW4pXHJcbiAgLy8gaWdub3JlZERpcmVjdG9yeUxpc3QgPSBpZ25vcmVkRGlyZWN0b3J5TGlzdC5tYXAoZGlyZW50ID0+IHBhdGguam9pbih0YXJnZXRQcm9qZWN0Um9vdCwgZGlyZW50Lm5hbWUpKSAvLyBnZXQgYWJzb2x1dGUgcGF0aHNcclxuICAvLyBnZXQgZGlyZW50IGxpc3QgdG8gZGVsZXRlXHJcbiAgbGV0IGRpcmVudFRvRGVsZXRlID0gZGlyZW50TGlzdC5maWx0ZXIoZGlyZW50ID0+ICFpZ25vcmVkRGlyZWN0b3J5TGlzdC5pbmNsdWRlcyhkaXJlbnQpKSAvLyByZW1vdmUgaWdub3JlZCBkaXJlbnRzIGZyb20gZGVsZXRlIGxpc3RcclxuICAvKiogRGVsZXRlIGRpcmVudCBsaXN0IHRoYXQgaW5jbHVkZXMgZGlyZWN0b3JpZXMgYW5kIGZpbGVzICovXHJcbiAgbGV0IGRlbGV0ZUFic29sdXRlUGF0aExpc3QgPSBkaXJlbnRUb0RlbGV0ZS5tYXAoZGlyZW50ID0+IHBhdGguam9pbih0YXJnZXRQcm9qZWN0Um9vdCwgZGlyZW50Lm5hbWUpKVxyXG4gIGZvciAobGV0IGFic29sdXRlUGF0aCBvZiBkZWxldGVBYnNvbHV0ZVBhdGhMaXN0KSB7XHJcbiAgICBmaWxlc3lzdGVtRXh0cmEucmVtb3ZlU3luYyhhYnNvbHV0ZVBhdGgpXHJcbiAgfVxyXG4gIC8vIGNvcHkgZGlzdHJpYnV0aW9uIGNvbnRlbnRzIHRvIHJvb3QgcHJvamVjdCBsZXZlbFxyXG4gIGZpbGVzeXN0ZW1FeHRyYS5jb3B5U3luYyh0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5kaXN0cmlidXRpb24sIHRhcmdldFByb2plY3RSb290KVxyXG5cclxuICAvLyBDcmVhdGUgY29tbWl0IG9mIGFsbCBmaWxlcy5cclxuICBsZXQgaW5kZXggPSBhd2FpdCByZXBvc2l0b3J5LnJlZnJlc2hJbmRleCgpIC8vIGludmFsaWRhdGVzIGFuZCBncmFicyBuZXcgaW5kZXggZnJvbSByZXBvc2l0b3J5LlxyXG4gIGxldCB0cmVlT2JqZWN0ID0gYXdhaXQgaW5kZXhcclxuICAgIC5hZGRBbGwoWycqKiddKVxyXG4gICAgLnRoZW4oKCkgPT4gaW5kZXgud3JpdGUoKSlcclxuICAgIC50aGVuKCgpID0+IGluZGV4LndyaXRlVHJlZSgpKSAvLyBhZGQgZmlsZXMgYW5kIGNyZWF0ZSBhIHRyZWUgb2JqZWN0LlxyXG4gIGxldCBwYXJlbnRDb21taXQgPSBhd2FpdCByZXBvc2l0b3J5LmdldEhlYWRDb21taXQoKSAvLyBnZXQgbGF0ZXN0IGNvbW1pdFxyXG4gIGF3YWl0IHJlcG9zaXRvcnlcclxuICAgIC5jcmVhdGVDb21taXQoXHJcbiAgICAgICdIRUFEJyAvKiB1cGRhdGUgdGhlIEhFQUQgcmVmZXJlbmNlIC0gc28gdGhhdCB0aGUgSEVBRCB3aWxsIHBvaW50IHRvIHRoZSBsYXRlc3QgZ2l0ICovIHx8IG51bGwgLyogZG8gbm90IHVwZGF0ZSByZWYgKi8sXHJcbiAgICAgIHRhZ2dlclNpZ25hdHVyZSxcclxuICAgICAgdGFnZ2VyU2lnbmF0dXJlLFxyXG4gICAgICBg8J+Pl++4jyBCdWlsZCBkaXN0cmlidXRpb24gY29kZS5gLFxyXG4gICAgICB0cmVlT2JqZWN0LFxyXG4gICAgICBbcGFyZW50Q29tbWl0XSxcclxuICAgIClcclxuICAgIC50aGVuKG9pZCA9PiBjb25zb2xlLmxvZyhg4oCiIENvbW1pdCBjcmVhdGVkICR7b2lkfSBmb3IgZGlzdHJpYnV0aW9uIGNvZGVgKSlcclxuXHJcbiAgLy8gdGFnIGFuZCBjcmVhdGUgYSByZWxlYXNlLlxyXG4gIGxldCBsYXRlc3RUZW1wb3JhcnlCcmFuY2hDb21taXQgPSBhd2FpdCByZXBvc2l0b3J5LmdldEhlYWRDb21taXQoKSAvLyBnZXQgbGF0ZXN0IGNvbW1pdFxyXG4gIGF3YWl0IGdpdC5UYWcuY3JlYXRlKHJlcG9zaXRvcnksIHRhZ05hbWUsIGxhdGVzdFRlbXBvcmFyeUJyYW5jaENvbW1pdCwgdGFnZ2VyU2lnbmF0dXJlLCBgUmVsZWFzZSBvZiBkaXN0cmlidXRpb24gY29kZSBvbmx5LmAsIDApLnRoZW4ob2lkID0+IGNvbnNvbGUubG9nKGDigKIgVGFnIGNyZWF0ZWQgJHtvaWR9YCkpXHJcblxyXG4gIC8vIG1ha2Ugc3VyZSB0aGUgYnJhbmNoIGlzIGNoZWNrZWRvdXQuXHJcbiAgYXdhaXQgcmVwb3NpdG9yeS5jaGVja291dEJyYW5jaChicmFjaFRvUG9pbnRUbykudGhlbihhc3luYyAoKSA9PiBjb25zb2xlLmxvZyhgQ2hlY2tlZCBicmFuY2ggJHthd2FpdCBicmFjaFRvUG9pbnRUby5uYW1lKCl9YCkpIC8vIGNoZWNrb3V0IGZvcm1lciBicmFuY2ggKHVzdWFsbHkgbWFzdGVyIGJyYW5jaClcclxuXHJcbiAgLy8gYXBwbHkgdGVtcG9yYXJseSBzdGFzaGVkIGZpbGVzXHJcbiAgaWYgKHN0YXR1c2VMaXN0Lmxlbmd0aCA+IDApIGF3YWl0IGdpdC5TdGFzaC5wb3AocmVwb3NpdG9yeSwgMCAvKiogbGFzdCBzdGFjaGVkIHBvc2l0aW9uICovKVxyXG59XHJcblxyXG4vKiogcmViYXNlIGludG8gbWFzdGVyIGJyYW5jaCB0byBmb2xsb3cgdGhlIGxhdGVzdCBtYXN0ZXIgY29tbWl0LiBUT0RPOiB0aGlzIGlzIGFuIGV4YW1wbGUgLSBmaXggYXN5bmMgb3BlcmF0aW9uLlxyXG4gKiAgVGhpcyBpcyBhbiBvcHRpb24gZm9yIHJlYmFzaW5nIGEgdGVtcG9yYXJ5IGJyYW5jaCB0byB0aGUgbGF0ZXN0IGNvbW1pdCAob3IgYSBuZXdlciBjb21taXQpLiBBbm90aGVyIG9wdGlvbiBpcyB0byB1c2UgYHJlc2V0YCB0byBhIGRpZmZlcmVudCBjb21taXQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWJhc2luZ0V4YW1wbGUoeyByZXBvc2l0b3J5LCBicmFuY2gsIGZyb21CcmFuY2gsIHRvQnJhbmNoIH0pIHtcclxuICByZXR1cm4gcmVwb3NpdG9yeS5yZWJhc2VCcmFuY2hlcyhcclxuICAgIGJyYW5jaC5uYW1lKCksIC8vIGJyYW5jaCBjb21taXRzIHRvIG1vdmVcclxuICAgIGZyb21CcmFuY2gubmFtZSgpLCAvLyB0aWxsIGNvbW1pdHMgdGhhdCBhcmUgaW50ZXJzZWN0ZWQgd2l0aCB0aGlzIGJyYW5jaCAob2xkIGJyYW5jaClcclxuICAgIHRvQnJhbmNoLm5hbWUoKSwgLy8gb250byB0aGUgbmV3IGJyYW5jaC5cclxuICAgIGdpdC5TaWduYXR1cmUubm93KCdtZW93JywgJ3Rlc3RAZXhhbXBsZS5jb20nKSxcclxuICAgIHJlYmFzZSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdPbmUgb3BlcmF0aW9uJylcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICB9LFxyXG4gICAgcmViYXNlTWV0YWRhdGEgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnRmluaXNoZWQgcmViYXNlJylcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICB9LFxyXG4gIClcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGVtcG9yYXJ5QnJhbmNoKHsgcmVwb3NpdG9yeSwgdGVtcG9yYXJ5QnJhbmNoIH0pIHtcclxuICAvLyBkZWxldGUgdGVtcG9yYXJ5IGJyYW5jaFxyXG4gIHRyeSB7XHJcbiAgICBpZiAoZ2l0LkJyYW5jaC5pc0NoZWNrZWRPdXQodGVtcG9yYXJ5QnJhbmNoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVsZXRlIGEgY2hlY2tlZCBvdXQgYnJhbmNoICR7YXdhaXQgdGVtcG9yYXJ5QnJhbmNoLm5hbWUoKX0uYClcclxuICAgIC8vIEJ5IHJlYXNzaWduaW5nIHRoZSB2YXJpYWJsZSBhbmQgbG9va2luZyB1cCB0aGUgYnJhbmNoIHRoZSBnYXJiYWdlIGNvbGxlY3RvciB3aWxsIGtpY2sgaW4uIFRoZSByZWZlcmVuY2UgZm9yIHRoZSBicmFuY2ggaW4gbGliZ2l0MiBzaG91bGRuJ3QgYmUgaW4gbWVtb3J5IGFzIG1lbnRpb25lZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2l0Mi9saWJnaXQyL2Jsb2IvODU5ZDkyMjkyZTAwOGE0ZDA0ZDY4ZmI2ZGMyMGExZGZhNjhlNDg3NC9pbmNsdWRlL2dpdDIvcmVmcy5oI0wzODUtTDM5OFxyXG4gICAgdGVtcG9yYXJ5QnJhbmNoID0gYXdhaXQgZ2l0LkJyYW5jaC5sb29rdXAocmVwb3NpdG9yeSwgdGVtcG9yYXJ5QnJhbmNoTmFtZSwgMSkgLy8gcmVmZXJlc2ggdmFsdWUgb2YgdGVtcG9yYXJ5QnJhbmNoIC0gZm9yIHNvbWUgcmVhc29uIHVzaW5nIHRoZSBzYW1lIHJlZmVyZW5jZSBwcmV2ZW50cyBkZWxldGlvbiBvZiBicmFuY2guXHJcbiAgICBsZXQgZXJyb3IgPSBnaXQuQnJhbmNoLmRlbGV0ZSh0ZW1wb3JhcnlCcmFuY2gpXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IG5ldyBFcnJvcihgQ29kZSB0aHJvd24gYnkgJ2xpYmdpdDInIGJpbmRpbmdzID0gJHtlcnJvcn1cXG4gXFx0Q2hlY2sgaHR0cHM6Ly93d3cubm9kZWdpdC5vcmcvYXBpL2Vycm9yLyNDT0RFYClcclxuICAgIGNvbnNvbGUubG9nKGDigKIgRGVsZXRlZCB0ZW1wb2FyYXJ5IGJyYW5jaCAke2F3YWl0IHRlbXBvcmFyeUJyYW5jaC5uYW1lKCl9LmApXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcbiJdfQ==